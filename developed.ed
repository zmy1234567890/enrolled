#include <math.h>

float calculate_phase_diff(float *signal1, float *signal2, int maxIndex) {
    // 计算信号1和信号2在主频位置的相位
    float phase1 = atan2(signal1[2 * maxIndex + 1], signal1[2 * maxIndex]);
    float phase2 = atan2(signal2[2 * maxIndex + 1], signal2[2 * maxIndex]);
    
    // 计算相位差
    float phase_diff = phase1 - phase2;
    
    // 保证相位差在[-π, π]范围内
    if (phase_diff > M_PI) {
        phase_diff -= 2 * M_PI;
    } else if (phase_diff < -M_PI) {
        phase_diff += 2 * M_PI;
    }
    
    return phase_diff;  // 返回相位差
}

float calculate_thd(const float* magnitude, int fundamental_index) {
    float v1 = magnitude[fundamental_index];
    float sum = 0.0f;
    for (int i = 2; i <= 6; i++) {
        int idx = i * fundamental_index;
        if (idx < FFT_SIZE / 2) {
            sum += magnitude[idx] * magnitude[idx];
        }
    }
    return sqrtf(sum) / v1 * 100.0f;
}

float calculate_amplitude_ratio(float *magnitude1, float *magnitude2, int maxIndex) {
    float amplitude1 = magnitude1[maxIndex];  // 信号1的幅度
    float amplitude2 = magnitude2[maxIndex];  // 信号2的幅度
    
    // 计算幅度比值
    if (amplitude2 != 0) {
        return amplitude1 / amplitude2;  // 返回幅度比值
    } else {
        return 0;  // 如果信号2的幅度为0，返回0（避免除零错误）
    }
}
float window[FFT_SIZE];

// 1. 生成 Hanning 窗口
void generate_hanning_window() {
    for (int i = 0; i < FFT_SIZE; i++) {
        window[i] = 0.5f * (1.0f - cosf(2 * PI * i / (FFT_SIZE - 1)));
    }
}

// 2. 对原始数据加窗，填充为复数输入
void apply_window_and_prepare_fft(float* input, float* output, float* window) {
    for (int i = 0; i < FFT_SIZE; i++) {
        output[i] = input[i] * window[i];
    }
}
